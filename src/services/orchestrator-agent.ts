/**
 * TLAU Orchestrator Agent
 * 
 * Master orchestrator: on every incoming prompt decide whether to use MCP resources,
 * log prompts for CEO review, and recommend MCP tools/workflows when applicable.
 */

import * as fs from 'fs';
import * as path from 'path';
import { initializeMCPRegistry, searchAvailableTools } from './mcp-registry';

export interface OrchestratorConfig {
  agent_name: string;
  version: string;
  description: string;
  hooks: {
    on_prompt_received: boolean;
    log_prompt: boolean;
    check_mcp: boolean;
    notify_ceo_agent: boolean;
  };
  mcp_registry: {
    registry_endpoint: string;
    availability_check_timeout_seconds: number;
  };
  logging: {
    log_path: string;
    metadata_fields: string[];
  };
  security: {
    strip_fields: string[];
    max_prompt_chars_for_log: number;
  };
  notify: {
    ceo_agent_endpoint: string;
    notify_on: string[];
  };
  decision_rules: {
    force_mcp_if: string[];
    prefer_local_if: string[];
  };
  outputs: {
    response_delivery: string;
    log_entry_return: boolean;
    ceo_notification_return: boolean;
  };
}

export interface PromptMetadata {
  timestamp: string;
  user_id?: string;
  prompt_summary: string;
  requires_mcp: boolean;
  mcp_candidates: string[];
  sensitive_data_removed: boolean;
  suggested_actions: string[];
  agent_id: string;
  original_prompt_length?: number;
  sanitized_prompt_length?: number;
}

export interface OrchestratorResult {
  should_use_mcp: boolean;
  mcp_candidates: string[];
  log_entry: PromptMetadata | null;
  ceo_notification: any | null;
  suggested_actions: string[];
}

const DEFAULT_CONFIG: OrchestratorConfig = {
  agent_name: "TLAU_Orchestrator_Agent",
  version: "1.0",
  description: "Master orchestrator: on every incoming prompt decide whether to use MCP resources, log prompts for CEO review, and recommend MCP tools/workflows when applicable.",
  hooks: {
    on_prompt_received: true,
    log_prompt: true,
    check_mcp: true,
    notify_ceo_agent: true,
  },
  mcp_registry: {
    registry_endpoint: "https://mcp-registry.local/api/servers",
    availability_check_timeout_seconds: 6,
  },
  logging: {
    log_path: "/Resources/prompt_logs/prompts.md",
    metadata_fields: ["timestamp", "user_id", "prompt_summary", "requires_mcp", "mcp_candidates", "sensitive_data_removed", "suggested_actions", "agent_id"],
  },
  security: {
    strip_fields: ["PRIVATE_KEY", "API_KEY", "PASSWORD", "GPS", "SSN"],
    max_prompt_chars_for_log: 8000,
  },
  notify: {
    ceo_agent_endpoint: "/AI-agents/CEO_Agent/inbox",
    notify_on: ["requires_mcp", "high_complexity", "new_feature_request"],
  },
  decision_rules: {
    force_mcp_if: ["requires_gpu", "long_running_task", "access_to_mcp_only_tools"],
    prefer_local_if: ["simple_copy_edit", "short_text_generation", "meta_request"],
  },
  outputs: {
    response_delivery: "normal_agent_response",
    log_entry_return: true,
    ceo_notification_return: true,
  },
};

export class TLAUOrchestratorAgent {
  private config: OrchestratorConfig;
  private logPath: string;
  private resourcesDir: string;

  constructor(config?: Partial<OrchestratorConfig>) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    // Resolve log path relative to workspace root
    this.resourcesDir = path.resolve(process.cwd(), 'Resources');
    this.logPath = path.resolve(process.cwd(), this.config.logging.log_path.replace(/^\//, ''));
    
    // Ensure Resources directory exists
    this.ensureResourcesDirectory();
  }

  /**
   * Ensure Resources directory structure exists
   */
  private ensureResourcesDirectory(): void {
    // Only create directories in Node.js environment
    if (typeof window === 'undefined' && typeof process !== 'undefined' && process.versions?.node) {
      try {
        const logDir = path.dirname(this.logPath);
        if (!fs.existsSync(logDir)) {
          fs.mkdirSync(logDir, { recursive: true });
        }
        
        // Initialize log file if it doesn't exist
        if (!fs.existsSync(this.logPath)) {
          const header = `# Prompt Logs\n\nGenerated by ${this.config.agent_name} v${this.config.version}\n\n---\n\n`;
          fs.writeFileSync(this.logPath, header, 'utf-8');
        }
      } catch (error) {
        console.warn('Failed to initialize Resources directory:', error);
      }
    }
  }

  /**
   * Main entry point: Process incoming prompt
   */
  async processPrompt(
    prompt: string,
    options?: {
      user_id?: string;
      context?: Record<string, any>;
    }
  ): Promise<OrchestratorResult> {
    if (!this.config.hooks.on_prompt_received) {
      return this.createDefaultResult(false, [], []);
    }

    // Step 1: Sanitize prompt for logging
    const sanitizedPrompt = this.sanitizePrompt(prompt);
    const promptSummary = this.generatePromptSummary(sanitizedPrompt);

    // Step 2: Analyze prompt to determine requirements
    const analysis = this.analyzePrompt(prompt, sanitizedPrompt);

    // Step 3: Check MCP registry availability
    let mcpCandidates: string[] = [];
    let requiresMCP = false;
    
    if (this.config.hooks.check_mcp) {
      const mcpCheck = await this.checkMCPAvailability(analysis);
      mcpCandidates = mcpCheck.candidates;
      requiresMCP = mcpCheck.requiresMCP;
    }

    // Step 4: Make decision about MCP vs local
    const shouldUseMCP = this.shouldUseMCP(analysis, requiresMCP, mcpCandidates);

    // Step 5: Generate suggested actions
    const suggestedActions = this.generateSuggestedActions(analysis, shouldUseMCP, mcpCandidates);

    // Step 6: Create metadata for logging
    const metadata: PromptMetadata = {
      timestamp: new Date().toISOString(),
      user_id: options?.user_id,
      prompt_summary: promptSummary,
      requires_mcp: shouldUseMCP,
      mcp_candidates: mcpCandidates,
      sensitive_data_removed: sanitizedPrompt !== prompt,
      suggested_actions: suggestedActions,
      agent_id: this.config.agent_name,
      original_prompt_length: prompt.length,
      sanitized_prompt_length: sanitizedPrompt.length,
    };

    // Step 7: Log prompt if enabled
    let logEntry: PromptMetadata | null = null;
    if (this.config.hooks.log_prompt) {
      logEntry = await this.logPrompt(metadata, sanitizedPrompt);
    }

    // Step 8: Notify CEO agent if needed
    let ceoNotification: any | null = null;
    if (this.config.hooks.notify_ceo_agent) {
      ceoNotification = await this.notifyCEOAgent(metadata, analysis);
    }

    return {
      should_use_mcp: shouldUseMCP,
      mcp_candidates: mcpCandidates,
      log_entry: this.config.outputs.log_entry_return ? logEntry : null,
      ceo_notification: this.config.outputs.ceo_notification_return ? ceoNotification : null,
      suggested_actions: suggestedActions,
    };
  }

  /**
   * Sanitize prompt by removing sensitive data
   */
  private sanitizePrompt(prompt: string): string {
    let sanitized = prompt;
    const sensitivePatterns = this.config.security.strip_fields.map(field => {
      // Create regex patterns for common sensitive data formats
      const patterns = [
        new RegExp(`${field}\\s*[:=]\\s*['"]?[^'"]+['"]?`, 'gi'),
        new RegExp(`${field}\\s*[:=]\\s*\\S+`, 'gi'),
      ];
      return patterns;
    }).flat();

    for (const pattern of sensitivePatterns) {
      sanitized = sanitized.replace(pattern, `${pattern.source.match(/^\^?([A-Z_]+)/)?.[1] || 'REDACTED'}=[REDACTED]`);
    }

    // Truncate if too long
    if (sanitized.length > this.config.security.max_prompt_chars_for_log) {
      sanitized = sanitized.substring(0, this.config.security.max_prompt_chars_for_log) + '\n... [truncated]';
    }

    return sanitized;
  }

  /**
   * Generate a summary of the prompt
   */
  private generatePromptSummary(prompt: string): string {
    // Simple summary: first 200 chars or first sentence
    const firstSentence = prompt.split(/[.!?]/)[0];
    if (firstSentence.length <= 200) {
      return firstSentence;
    }
    return prompt.substring(0, 200) + '...';
  }

  /**
   * Analyze prompt to determine requirements
   */
  private analyzePrompt(prompt: string, sanitizedPrompt: string): {
    keywords: string[];
    complexity: 'low' | 'medium' | 'high';
    requiresGPU: boolean;
    longRunning: boolean;
    needsMCPTools: boolean;
    isMetaRequest: boolean;
    isSimpleEdit: boolean;
  } {
    const lowerPrompt = prompt.toLowerCase();
    
    // Check for GPU requirements
    const gpuKeywords = ['gpu', 'cuda', 'tensor', 'model', 'training', 'inference', 'neural', 'deep learning'];
    const requiresGPU = gpuKeywords.some(kw => lowerPrompt.includes(kw));

    // Check for long-running tasks
    const longRunningKeywords = ['process', 'batch', 'analyze all', 'generate report', 'scan', 'crawl', 'index'];
    const longRunning = longRunningKeywords.some(kw => lowerPrompt.includes(kw));

    // Check for MCP-specific tool needs
    const mcpKeywords = ['github', 'vercel', 'deploy', 'database', 'supabase', 'paypal', 'subscription', 'auth'];
    const needsMCPTools = mcpKeywords.some(kw => lowerPrompt.includes(kw));

    // Check for meta requests
    const metaKeywords = ['how to', 'what is', 'explain', 'help me understand', 'show me'];
    const isMetaRequest = metaKeywords.some(kw => lowerPrompt.includes(kw));

    // Check for simple edits
    const simpleEditKeywords = ['fix typo', 'change', 'replace', 'update text', 'edit'];
    const isSimpleEdit = simpleEditKeywords.some(kw => lowerPrompt.includes(kw)) && prompt.length < 500;

    // Determine complexity
    let complexity: 'low' | 'medium' | 'high' = 'low';
    if (requiresGPU || longRunning || (prompt.length > 2000)) {
      complexity = 'high';
    } else if (needsMCPTools || prompt.length > 500) {
      complexity = 'medium';
    }

    return {
      keywords: [...new Set([...gpuKeywords.filter(k => lowerPrompt.includes(k)),
                            ...longRunningKeywords.filter(k => lowerPrompt.includes(k)),
                            ...mcpKeywords.filter(k => lowerPrompt.includes(k))])],
      complexity,
      requiresGPU,
      longRunning,
      needsMCPTools,
      isMetaRequest,
      isSimpleEdit,
    };
  }

  /**
   * Check MCP registry availability and find relevant tools
   */
  private async checkMCPAvailability(analysis: ReturnType<typeof this.analyzePrompt>): Promise<{
    requiresMCP: boolean;
    candidates: string[];
  }> {
    try {
      // Initialize MCP registry
      await initializeMCPRegistry();

      // Search for relevant tools based on keywords
      const candidates: string[] = [];
      
      if (analysis.needsMCPTools) {
        // Search for tools matching keywords
        for (const keyword of analysis.keywords) {
          try {
            const tools = await Promise.race([
              searchAvailableTools(keyword, { limit: 10 }),
              new Promise<any[]>((resolve) => 
                setTimeout(() => resolve([]), this.config.mcp_registry.availability_check_timeout_seconds * 1000)
              ),
            ]);
            
            if (tools && Array.isArray(tools)) {
              tools.forEach((tool: any) => {
                const toolName = tool.name || tool.tool || `${tool.namespace || 'unknown'}:${tool.name || 'unknown'}`;
                if (!candidates.includes(toolName)) {
                  candidates.push(toolName);
                }
              });
            }
          } catch (error) {
            // Continue searching other keywords
            console.warn(`Failed to search MCP tools for keyword "${keyword}":`, error);
          }
        }
      }

      const requiresMCP = analysis.requiresGPU || analysis.longRunning || analysis.needsMCPTools || candidates.length > 0;

      return {
        requiresMCP,
        candidates: candidates.slice(0, 10), // Limit to top 10
      };
    } catch (error) {
      console.warn('MCP registry check failed:', error);
      return {
        requiresMCP: false,
        candidates: [],
      };
    }
  }

  /**
   * Determine if MCP should be used based on decision rules
   */
  private shouldUseMCP(
    analysis: ReturnType<typeof this.analyzePrompt>,
    requiresMCP: boolean,
    mcpCandidates: string[]
  ): boolean {
    // Force MCP if any force conditions are met
    if (analysis.requiresGPU || analysis.longRunning || (mcpCandidates.length > 0 && analysis.needsMCPTools)) {
      return true;
    }

    // Prefer local if simple edit or meta request
    if (analysis.isSimpleEdit || analysis.isMetaRequest) {
      return false;
    }

    // Default to MCP if candidates found and needs MCP tools
    return requiresMCP && mcpCandidates.length > 0;
  }

  /**
   * Generate suggested actions based on analysis
   */
  private generateSuggestedActions(
    analysis: ReturnType<typeof this.analyzePrompt>,
    shouldUseMCP: boolean,
    mcpCandidates: string[]
  ): string[] {
    const actions: string[] = [];

    if (shouldUseMCP) {
      if (mcpCandidates.length > 0) {
        actions.push(`Use MCP tools: ${mcpCandidates.slice(0, 3).join(', ')}`);
      } else {
        actions.push('Consider using MCP resources for this task');
      }
    } else {
      actions.push('Process locally using standard agent capabilities');
    }

    if (analysis.complexity === 'high') {
      actions.push('High complexity detected - consider breaking into smaller tasks');
    }

    if (analysis.requiresGPU) {
      actions.push('GPU resources may be required');
    }

    if (analysis.longRunning) {
      actions.push('This appears to be a long-running task - monitor execution time');
    }

    return actions;
  }

  /**
   * Log prompt to file
   */
  private async logPrompt(metadata: PromptMetadata, sanitizedPrompt: string): Promise<PromptMetadata> {
    // Only log to file in Node.js environment
    if (typeof window === 'undefined' && typeof process !== 'undefined' && process.versions?.node) {
      try {
        const logEntry = this.formatLogEntry(metadata, sanitizedPrompt);
        
        // Append to log file
        fs.appendFileSync(this.logPath, logEntry + '\n\n', 'utf-8');
      } catch (error) {
        console.error('Failed to log prompt:', error);
      }
    } else {
      // In browser environment, log to console instead
      console.log('Prompt Log Entry:', metadata);
    }
    
    return metadata;
  }

  /**
   * Format log entry as markdown
   */
  private formatLogEntry(metadata: PromptMetadata, sanitizedPrompt: string): string {
    const fields = this.config.logging.metadata_fields;
    const entry: string[] = [];

    entry.push(`## Prompt Entry - ${metadata.timestamp}`);
    entry.push('');

    // Add metadata fields
    fields.forEach(field => {
      const value = (metadata as any)[field];
      if (value !== undefined && value !== null) {
        if (Array.isArray(value)) {
          entry.push(`- **${field}**: ${value.join(', ')}`);
        } else if (typeof value === 'boolean') {
          entry.push(`- **${field}**: ${value ? 'Yes' : 'No'}`);
        } else {
          entry.push(`- **${field}**: ${value}`);
        }
      }
    });

    entry.push('');
    entry.push('### Prompt Content:');
    entry.push('```');
    entry.push(sanitizedPrompt);
    entry.push('```');
    entry.push('');
    entry.push('---');

    return entry.join('\n');
  }

  /**
   * Notify CEO agent if conditions are met
   */
  private async notifyCEOAgent(
    metadata: PromptMetadata,
    analysis: ReturnType<typeof this.analyzePrompt>
  ): Promise<any | null> {
    const shouldNotify = this.config.notify.notify_on.some(condition => {
      switch (condition) {
        case 'requires_mcp':
          return metadata.requires_mcp;
        case 'high_complexity':
          return analysis.complexity === 'high';
        case 'new_feature_request':
          return analysis.keywords.some(kw => ['feature', 'add', 'implement', 'create'].includes(kw.toLowerCase()));
        default:
          return false;
      }
    });

    if (!shouldNotify) {
      return null;
    }

    const notification = {
      timestamp: metadata.timestamp,
      agent_id: this.config.agent_name,
      reason: this.config.notify.notify_on.filter(condition => {
        switch (condition) {
          case 'requires_mcp':
            return metadata.requires_mcp;
          case 'high_complexity':
            return analysis.complexity === 'high';
          case 'new_feature_request':
            return analysis.keywords.some(kw => ['feature', 'add', 'implement', 'create'].includes(kw.toLowerCase()));
          default:
            return false;
        }
      }),
      metadata,
      endpoint: this.config.notify.ceo_agent_endpoint,
    };

    // In a real implementation, this would send to CEO agent endpoint
    // For now, we'll just log it
    console.log('CEO Agent Notification:', JSON.stringify(notification, null, 2));

    return notification;
  }

  /**
   * Create default result
   */
  private createDefaultResult(shouldUseMCP: boolean, mcpCandidates: string[], suggestedActions: string[]): OrchestratorResult {
    return {
      should_use_mcp: shouldUseMCP,
      mcp_candidates: mcpCandidates,
      log_entry: null,
      ceo_notification: null,
      suggested_actions: suggestedActions,
    };
  }

  /**
   * Get current configuration
   */
  getConfig(): OrchestratorConfig {
    return { ...this.config };
  }

  /**
   * Update configuration
   */
  updateConfig(updates: Partial<OrchestratorConfig>): void {
    this.config = { ...this.config, ...updates };
    // Update log path if changed
    if (updates.logging?.log_path) {
      this.logPath = path.resolve(process.cwd(), updates.logging.log_path.replace(/^\//, ''));
      this.ensureResourcesDirectory();
    }
  }
}

// Export singleton instance
let orchestratorInstance: TLAUOrchestratorAgent | null = null;

/**
 * Get or create orchestrator instance
 */
export function getOrchestratorAgent(config?: Partial<OrchestratorConfig>): TLAUOrchestratorAgent {
  if (!orchestratorInstance) {
    orchestratorInstance = new TLAUOrchestratorAgent(config);
  }
  return orchestratorInstance;
}

/**
 * Initialize orchestrator with custom config
 */
export function initializeOrchestrator(config: Partial<OrchestratorConfig>): TLAUOrchestratorAgent {
  orchestratorInstance = new TLAUOrchestratorAgent(config);
  return orchestratorInstance;
}
